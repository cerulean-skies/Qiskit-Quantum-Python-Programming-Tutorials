import sys
sys.path.append("../../qiskit-sdk-py/")
from qiskit import QuantumProgram
import Qconfig
import math
import matplotlib.pyplot as plt


qp = QuantumProgram()
qp.set_api(Qconfig.APItoken, Qconfig.config["url"]) # set the APIToken and API url

# set up registers and program
qr = qp.create_quantum_register('qr', 16)
cr = qp.create_classical_register('cr', 16)
qc = qp.create_circuit('Quantum_Emoticon', [qr], [cr])

#The ':' ASCII character = '00111010', and the next character 'O' = '01001111' so we will use X, or NOT Gates to set all of
# the shared '1's in this string. Printing this out now would simply display a ':O'.
qc.x(qr[3])
qc.x(qr[4])
qc.x(qr[6])
qc.x(qr[9])
qc.x(qr[11])
qc.x(qr[12])
qc.x(qr[13])


#Now, the differences between '01010000',meaning 'O' and '01001111', meaning 'P' are = 010*****, where asterisks are variable.
#To accomplish this in our function, we will need to superimpose some of these bits using A Hadamard Gate, as well as a series of
# CNOT Gates.
qc.h(qr[3]) #Place Qubit 3 into a state of Superposition.
qc.cx(qr[3],qr[2]) #Entangle Cubit 3's fate with Qubit 2.
qc.cx(qr[2],qr[1]) #Entangle Cubit 2's fate with Qubit 1.
qc.cx(qr[1],qr[0]) #Entangle Cubit 1's fate with Qubit 0.

qc.cx(qr[3],qr[4]) #Entangle Cubit 3's fate with Qubit 4. This is key to the equation.

# measure
#for j in range(16):
 #   qc.measure(qr[j], cr[j])
qc.measure(qr[0], cr[0])
qc.measure(qr[1], cr[1])
qc.measure(qr[2], cr[2])
qc.measure(qr[3], cr[3])
qc.measure(qr[4], cr[4])
qc.measure(qr[5], cr[5])
qc.measure(qr[6], cr[6])
qc.measure(qr[7], cr[7])
qc.measure(qr[8], cr[8])
qc.measure(qr[9], cr[9])
qc.measure(qr[10], cr[10])
qc.measure(qr[11], cr[11])
qc.measure(qr[12], cr[12])
qc.measure(qr[13], cr[13])
qc.measure(qr[14], cr[14])
qc.measure(qr[15], cr[15])

# run and get results
returned = qp.execute(["Quantum_Emoticon"], backend='ibmq_qasm_simulator', shots=1024, timeout=600)
bitStrings = returned.get_counts("Quantum_Emoticon")

print(str(bitStrings))

# For each string in 'Bitsrings' We will convert first 8 bits of data to a single ASCII character, stored in a variable,
# and do the same for the final 8 bits.
StringDictionary = {}
for bits in bitStrings:
    char1 = chr(int( bits[0:8] ,2))
    char2 = chr(int( bits[8:16] ,2))
    StringDictionary[ char1 + char2 ] = bitStrings[bits] / 1024


# Finally, we will graphically plot the output, so as to get a nice visual on what is happening. The combatting characters will be overlayed
# on top of each other, according to how often they crop up in our returned data.
plt.rc('font', family='monospace')
for char in StringDictionary.keys():
    plt.annotate( char, (0.5,0.5), va="center", ha="center", color = (0,0,0,StringDictionary[char]), size = 250)
plt.axis('off')
plt.show()
